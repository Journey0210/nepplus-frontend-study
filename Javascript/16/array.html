<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
       const numbers = ["one", "two", "three", "four"]; //배열 인스턴스 선언 방법
       for (let i = 0; i < numbers.length; i++) {
         //현재 numbers.length는 4
         document.write(`<p>${numbers[i]}</p>`);
       }

       //배열끼리 합치는 concat()메서드
       const nums = [1, 2, 3];
       const chars = ["a", "b", "c", "d"];
       const numsChars = nums.concat(chars);
       const charsNums = chars.concat(nums);
       // const numsChars = [...nums, ...chars]; ES6문법 nums의 배열 알맹이 ,chars의 배열 알맹이***
       // const numsChars = [1,2,3,"a","b","c","d"]
       document.write(
         `nums에 chars를 합치면: ${numsChars}<br> chars에 nums를 합치면: ${charsNums}`
       );

       document.write(`<br>`);

       // 배열요소를 ->하나의 문자열로 만들어주는 join()메서드
       document.write(`<br>`);
       const string1 = nums.join();
       document.write(`구분자 없이: ${string1}`); //쉼표를 넣어서 string을 만든다.
       document.write(`<br>`);
       const string2 = nums.join("/");
       document.write(`/구분자지정: ${string2}`);
       const string3 = nums.join(" "); //빈 문자열을 넣어서 string 을 만들면 문자 사이사이의 기본값 쉼표가 사라진다.
       document.write(`구분 쉼표 없애기: ${string3}`);

       document.write(`<br>`);

       // 문자를 ->배열로 만드는 split()메서드 얘는 string객체의 메서드이다.
            >"1234".split()
             ['1234']

      //인덱스 값을 반환하는(찾는) indexOf() 메서드
           ["a","b","c","d","d"].indexOf("d") // 조건을 만족하는 첫번째 요소의 인덱스를 반환 // expected output:3
           ["a","b","c","d","d"].lastIndexOf("d")//// expected output:4


       //새로운 요소를 추가하는 push(), unshift() 메서드 , return 값이 length
       document.write(`<br>`);
       const ret1 = nums.push(4, 5); //맨 끝에 4,5 추가
       document.write(`length: ${ret1}| 배열 ; ${nums}`);
       document.write(`<br>`);
       const ret2 = nums.unshift(0); // 맨 앞에 0추가
       document.write(`length: ${ret2}| 배열 ; ${nums}`);

       document.write(`<br>`);

       //배열 요소를 꺼내는 pop(), shift()메서드
       document.write(`<br>`);
       const popped1 = chars.pop(); //마지막 요소 꺼냄
       document.write(`꺼낸요소: ${popped1}|배열:${chars}`);
       document.write(`<br>`);
       const popped2 = chars.shift(); //첫번째 요소 꺼냄
       document.write(`꺼낸요소: ${popped2}|배열:${chars}`);

       document.write(`<br>`);

       //원하는 위치에 요소를 추가, 삭제하는 splice()메서드
       //1. 인수가 1개인 경우
       document.write(`<br>`);
       const newNumbers = numbers.splice(2); //numbers[2] 즉 '인덱스'가 2인 요소부터 마지막 요소까지 잘라냄
       document.write(`반환된 배열: ${newNumbers}<br>`);
       document.write(`변경된 배열: ${numbers}<br>`); // splice()는 원본배열에 영향을 줌

       document.write(`<br>`);

       //2.인수가 2개인 경우
       document.write(`<br>`);
       const study = ["html", "css", "web", "jquery"];
       const newStudy = study.splice(2, 1); // 인덱스가 2인요소부터 1개만 잘라냄
       document.write(`반환된 배열: ${newStudy}<br/>`);
       document.write(`변경된 배열: ${study}`);

       //3.인수가 3개인 경우
       document.write(`<br>`);
       const newStudy2 = study.splice(2, 1, "js"); //인덱스가 2인 요소부터 1개만 잘라냄.(return은 여기까지) 그리고 "js"를 거기에 넣음
       document.write(`반환된 배열:${newStudy2}<br>`);
       document.write(`변경된 배열:${study}`);
       document.write(`<br>`);

       //기존 배열을 바꾸지 않으면서 요소를 꺼내는 slice()메서드
       //1.인수가 1개일 경우
       document.write(`<br>`);
       const colors = ["red", "green", "blue", "white", "black"];
       const colors2 = colors.slice(2); // 인덱스가 2인 요소부터 끝까지 잘라냄.
       document.write(colors2);
       document.write(`<br>`);
       document.write(colors); // 출력해보면 원본 배열에는 영향이 없음
       document.write(`<br>`);
       //1.인수가 2개일 경우
       document.write(`<br>`);
       const colors3 = colors.slice(2, 4); //인덱스가 2인 요소부터 인덱스가 4인 요소 "전!"까지 잘라냄
       document.write(colors3);
       document.write(`<br>`);

       //sort()함수 : 오름차순 정렬: sort((a,b)=>{a-b}) 내림차순 정렬: sort((a,b)=>(b-a))

       //서버에서 보내준 데이터는 객체가 담긴 배열인 경우가 많음. 프론트엔드 개발자는 이를 가공해서 출력하는 일을 함.
       //배열을 다루는 코딩테스트를 많이 해보는 것을 추천함.
       //아래는 객체가 담긴 배열의 예시.
       //   [{thumbnail:"이미지주소",
       //     title:"오가닉 유아내의",
       //      content:"아동내의 45%"},

       //      {thumbnail:"이미지주소",
       //     title:"오가닉 유아내의",
       //      content:"아동내의 45%"},

       //      {thumbnail:"이미지주소",
       //     title:"오가닉 유아내의",
       //      content:"아동내의 45%"}]


       //map(e=>()) : 엘리먼트들을 수정하여 새로운 배열 반환
       [1,2,3,4].map((num)=>{return num*2})//첫번째 인자로 콜백함수가 들어온다.  기존의 배열과 같은 길이의 '배열'을 리턴
       [2,4,6,8]을 반환

       2차원 배열에 접근하기
       const arr = [[1,2],[3,4]]
       arr[0] = [1,2]
       arr[1] = [3,4]
       arr[0][0] = 1
       arr[0][1] = 2
       arr[1][0] = 3
       arr[1][1] = 4

       **숫자 => 문자열
        방법1. 123 + "" => "123" //숫자에 + ""을 한다.
        방법2. String(123)=>"123"
       **문자열 => 숫자
        방법1. +"123" => 123  // 문자열 앞에 + 를 한다.
        방법2. Number("123")
       *문자열 => 배열
      "123".split() => ['123']
      "123".split("") => ['1','2','3']
       *배열 => 문자열
       ['1','2','3'].join() => '1,2,3' //기본값으로 ,가 찍힌다. 괄호 안에 구분자를 넣을 수 있음.
       ['1','2','3'].join("") => '123'
       ['1','2','3'].join("/") => '1/2/3'
    </script>
  </body>
</html>
